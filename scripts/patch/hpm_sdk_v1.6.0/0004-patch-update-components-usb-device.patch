From f832e32293086794dd2762f5ce8c7cac5ebfdd80 Mon Sep 17 00:00:00 2001
From: Zhihong Chen <zhihong.chen@hpmicro.com>
Date: Wed, 7 May 2025 16:04:42 +0800
Subject: [PATCH] [update] components: usb: device: update usb device component

- update usb device component

Signed-off-by: Zhihong Chen <zhihong.chen@hpmicro.com>
---
 hpm_sdk/components/usb/device/hpm_usb_device.c | 14 +++++++++-----
 hpm_sdk/components/usb/device/hpm_usb_device.h |  6 ++++--
 2 files changed, 13 insertions(+), 7 deletions(-)

diff --git a/hpm_sdk/components/usb/device/hpm_usb_device.c b/hpm_sdk/components/usb/device/hpm_usb_device.c
index 4c7fd3849..79fc5fb12 100644
--- a/hpm_sdk/components/usb/device/hpm_usb_device.c
+++ b/hpm_sdk/components/usb/device/hpm_usb_device.c
@@ -91,15 +91,14 @@ bool usb_device_init(usb_device_handle_t *handle, uint32_t int_mask)
 
 void usb_device_deinit(usb_device_handle_t *handle)
 {
-    /* Clear memroy */
-    memset(handle->dcd_data, 0, sizeof(dcd_data_t));
-
-    usb_dcd_deinit(handle->regs);
-
     for (uint32_t i = 0; i < USB_SOC_DCD_MAX_ENDPOINT_COUNT; i++) {
         usb_dcd_edpt_close(handle->regs, (i | (usb_dir_in  << 0x07)));
         usb_dcd_edpt_close(handle->regs, (i | (usb_dir_out << 0x07)));
     }
+
+    usb_dcd_deinit(handle->regs);
+
+    memset(handle->dcd_data, 0, sizeof(dcd_data_t));
 }
 
 uint32_t usb_device_status_flags(usb_device_handle_t *handle)
@@ -206,6 +205,9 @@ bool usb_device_edpt_open(usb_device_handle_t *handle, usb_endpoint_config_t *co
     p_qhd = &handle->dcd_data->qhd[ep_idx];
     memset(p_qhd, 0, sizeof(dcd_qhd_t));
 
+    if (ep_idx == 0) {
+        p_qhd->int_on_setup = 1;
+    }
     p_qhd->zero_length_termination = 1;
     p_qhd->max_packet_size         = config->max_packet_size & 0x7FFu;
     p_qhd->qtd_overlay.next        = USB_SOC_DCD_QTD_NEXT_INVALID;
@@ -248,6 +250,7 @@ bool usb_device_edpt_xfer(usb_device_handle_t *handle, uint8_t ep_addr, uint8_t
         buffer = (uint8_t *)core_local_mem_to_sys_address(0, (uint32_t)buffer);
     }
     p_qhd = &handle->dcd_data->qhd[ep_idx];
+    p_qhd->attached_buffer = (uint32_t)buffer;
     i = 0;
     do {
         p_qtd = &handle->dcd_data->qtd[ep_idx * USB_SOC_DCD_QTD_COUNT_EACH_ENDPOINT + i];
@@ -275,6 +278,7 @@ bool usb_device_edpt_xfer(usb_device_handle_t *handle, uint8_t ep_addr, uint8_t
         prev_p_qtd = p_qtd;
     } while (total_bytes > 0);
 
+    p_qhd->attached_qtd = first_p_qtd;
     p_qhd->qtd_overlay.next = core_local_mem_to_sys_address(0, (uint32_t) first_p_qtd); /* link qtd to qhd */
 
     usb_dcd_edpt_xfer(handle->regs, ep_idx);
diff --git a/hpm_sdk/components/usb/device/hpm_usb_device.h b/hpm_sdk/components/usb/device/hpm_usb_device.h
index 71142f6af..48739b48f 100644
--- a/hpm_sdk/components/usb/device/hpm_usb_device.h
+++ b/hpm_sdk/components/usb/device/hpm_usb_device.h
@@ -41,7 +41,7 @@ typedef struct {
     volatile uint32_t                      : 3;
     volatile uint32_t int_on_complete      : 1;
     volatile uint32_t total_bytes          : 15;
-    volatile uint32_t                      : 0;
+    volatile uint32_t                      : 1;
 
     /* Word 2-6: Buffer Page Pointer List, Each element in the list is a 4K page aligned, physical memory address. The lower 12 bits in each pointer are reserved (except for the first one) as each memory pointer must reference the start of a 4K page */
     volatile uint32_t buffer[USB_SOC_DCD_QHD_BUFFER_COUNT];
@@ -77,7 +77,9 @@ typedef struct {
      * thus there are 16 bytes padding free that we can make use of.
      *--------------------------------------------------------------------
      */
-    volatile uint8_t reserved[16];
+    volatile uint32_t attached_buffer;
+    dcd_qtd_t * volatile attached_qtd;
+    volatile uint8_t reserved[8];
 } dcd_qhd_t;
 
 typedef struct {
-- 
2.45.2.windows.1

